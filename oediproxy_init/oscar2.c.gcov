        -:    0:Source:oscar2.c
        -:    0:Graph:oscar2.gcno
        -:    0:Data:oscar2.gcda
        -:    0:Runs:1
        -:    0:Programs:2
        -:    1:#include "oscar2.h"
        -:    2:
        1:    3:struct frame_queue_t *frame_enqueue(struct frame_queue_t *cur, char *buf, int l, int fixup_seqno) {
        1:    4:  struct frame_queue_t *my_frame = (struct frame_queue_t *)malloc(sizeof(struct frame_queue_t));
        -:    5:
        1:    6:  my_frame->f.buf = buf;
        1:    7:  my_frame->f.l = l;
        1:    8:  my_frame->fixup_seqno = fixup_seqno;
        1:    9:  my_frame->next = NULL;
        -:   10:
        1:   11:  if(cur) {
    #####:   12:    cur->next = my_frame;
    #####:   13:    return cur;
        -:   14:  }
        -:   15:
        1:   16:  return my_frame;
        -:   17:}
        -:   18:
    #####:   19:struct frame_queue_t *frame_enqueue_dupfrag(struct frame_queue_t *cur, char *buf, int offset, int l, int fixup_seqno) {
        -:   20:  char *my_buf;
        -:   21:  int my_len;
        -:   22:
    #####:   23:  my_len = l - offset;
        -:   24:
    #####:   25:  if(0 >= my_len) {
    #####:   26:    my_len = 0;
    #####:   27:    my_buf = NULL;
        -:   28:  } else {
    #####:   29:    my_buf = (char *)malloc(my_len);
    #####:   30:    memcpy(my_buf, buf+offset, my_len);
        -:   31:  }
        -:   32:
    #####:   33:  return frame_enqueue(cur, my_buf, my_len, fixup_seqno);
        -:   34:}
        -:   35:
    #####:   36:struct frame_queue_t *frame_enqueue_append(struct frame_queue_t *queue, struct frame_queue_t *tail) {
        -:   37:
    #####:   38:  if(!queue) {
    #####:   39:    queue = tail;
        -:   40:  } else { 
    #####:   41:    struct frame_queue_t *cursor = queue;
    #####:   42:    while(cursor->next)
    #####:   43:      cursor = cursor->next;
    #####:   44:    cursor->next = tail;
        -:   45:  }
        -:   46:
    #####:   47:  return queue;
        -:   48:}
        -:   49:
    #####:   50:void of_init(struct oedifilter_state *s) {
    #####:   51:  s->flow_state = PREHEADER;
    #####:   52:  s->seqno = 0x1899;
        -:   53:
    #####:   54:  memset(s->header, 0x00, HEADER_LEN);
        -:   55:
    #####:   56:  s->body_len = 0;
    #####:   57:  s->body_buf = NULL;
    #####:   58:  s->body_pos = 0;
        -:   59:
    #####:   60:  s->to_inject = NULL;
    #####:   61:  s->to_sanitize = NULL;
    #####:   62:}
        -:   63:
    #####:   64:struct frame_queue_t *of_frame_inject(struct oedifilter_state *s, struct frame_queue_t *queue) {
        -:   65:
    #####:   66:  queue = frame_enqueue_append(queue, s->to_inject);
        -:   67:
        -:   68:  /* Clear the internal inject queue */
    #####:   69:  s->to_inject = NULL;
        -:   70:
        -:   71:  /* Return the filled frame queue */
    #####:   72:  return queue;
        -:   73:}
        -:   74:
    #####:   75:void of_load_header(struct oedifilter_state *s, char *orig_header, char chan, unsigned short seqno, unsigned short len) {
    #####:   76:  memset(s->header, 0x00, HEADER_LEN);
    #####:   77:  s->body_len = HEADER_LEN+len;
    #####:   78:  s->body_buf = (char *)malloc(len+HEADER_LEN);
    #####:   79:  s->body_pos = HEADER_LEN;
        -:   80:
    #####:   81:  memcpy(s->body_buf, orig_header, HEADER_LEN);
    #####:   82:}
        -:   83:
        -:   84:
        -:   85:
    #####:   86:int of_attempt_header_parse(struct oedifilter_state *s, char *buf, int pos) {
        -:   87:  unsigned char chan;
        -:   88:  signed short seqno;
        -:   89:  unsigned short len;
        -:   90: 
    #####:   91:  if(buf[pos] != 0x2A)
    #####:   92:    return -1;
        -:   93:
    #####:   94:  chan = buf[pos+1];
        -:   95:
    #####:   96:  if(chan > 5)
    #####:   97:    return -2;
        -:   98:
    #####:   99:  seqno = aimutil_get16(buf+pos+1+1);
    #####:  100:  len = aimutil_get16(buf+pos+1+1+2);
        -:  101:
    #####:  102:  if(s)
    #####:  103:    of_load_header(s, buf+pos, chan, seqno, len);
        -:  104:  
    #####:  105:  return 1;
        -:  106:}
        -:  107:
    #####:  108:int of_scan_to_header(struct frame_t *f, int pos) {
        -:  109:  int i;
        -:  110:
    #####:  111:  for(i = pos; (i+HEADER_LEN) < f->l; i++) {
    #####:  112:    if(*(f->buf+i) == 0x2A) {
        -:  113:      /* got magic, try to parse header */
    #####:  114:      if(1 == of_attempt_header_parse(NULL, f->buf, i))
    #####:  115:	return i;
        -:  116:    }
        -:  117:  }
        -:  118:
        -:  119:  /* none found */
    #####:  120:  return -1;
        -:  121:}
        -:  122:
        -:  123:/* Note that queue_p here is a pointer to a pointer! */
    #####:  124:int of_load_body(struct oedifilter_state *s, struct frame_queue_t **queue_p, char *buf, int len, int pos) {
    #####:  125:  int buf_left = len - pos;
    #####:  126:  int body_left = s->body_len - s->body_pos;
        -:  127:  
    #####:  128:  int copy_chunk = buf_left > body_left ? body_left : buf_left;
        -:  129:
        -:  130:  /* Copy all the data we can in */
    #####:  131:  memcpy(s->body_buf+s->body_pos, buf+pos, copy_chunk);
    #####:  132:  s->body_pos += copy_chunk;
        -:  133:
    #####:  134:  pos += copy_chunk;
        -:  135:
    #####:  136:  if(s->body_pos >= s->body_len) {
        -:  137:    /* parse body if full:
        -:  138:       - extract events
        -:  139:       - queue for xmit unless sanitized
        -:  140:       reset state to PREHEADER
        -:  141:    */
        -:  142:
        -:  143:  }
        -:  144:
    #####:  145:  return pos;
        -:  146:}
        -:  147:
        -:  148:/* never frees its input, and you need to free all frames it
        -:  149:   returns */
    #####:  150:struct frame_queue_t * of_run(struct oedifilter_state *s, struct frame_t *f) {
    #####:  151:  int pos = 0;
    #####:  152:  struct frame_queue_t *retval = NULL;
        -:  153:
    #####:  154:  if(!s || !f)
    #####:  155:    return NULL;
        -:  156:
    #####:  157:  while(pos < f->l) {
    #####:  158:    if(PREHEADER == s->flow_state) {
        -:  159:      /* scan for the next OSCAR HEADER */
    #####:  160:      int next_header = of_scan_to_header(f, pos);
    #####:  161:      if(-1 == next_header) {
        -:  162:	/* No header found in this buffer, just queue it out */
    #####:  163:        retval = frame_enqueue_dupfrag(retval, f->buf, pos, f->l-pos, NO_SEQNO_FIXUP);
    #####:  164:	pos = f->l;
        -:  165:      } else {
        -:  166:	/* enqueue up to next_header, change state, and go */
    #####:  167:        retval = frame_enqueue_dupfrag(retval, f->buf, pos, next_header-pos, NO_SEQNO_FIXUP);
        -:  168:
        -:  169:	/* inject pending frames */
    #####:  170:	retval = of_frame_inject(s, retval);
        -:  171:	
        -:  172:	/* update machine state */
    #####:  173:	pos = next_header;
    #####:  174:	s->flow_state = INHEADER;
        -:  175:      }
        -:  176:    }
        -:  177:
    #####:  178:    if(INHEADER == s->flow_state) {
    #####:  179:      of_attempt_header_parse(s, f->buf, pos);
    #####:  180:      pos += HEADER_LEN;
    #####:  181:      s->flow_state = INBODY;
        -:  182:    }
        -:  183:
    #####:  184:    if(INBODY == s->flow_state) {
        -:  185:      /* fill up body buf */
        -:  186:
        -:  187:
        -:  188:      /* of_load_body updates the state and queue for us */
    #####:  189:      pos = of_load_body(s, &retval, f->buf, f->l, pos);
        -:  190:    }
        -:  191:  }
        -:  192:
        -:  193:  /* XXX TODO Fixup seqnos */
    #####:  194:  return retval;
        -:  195:}
